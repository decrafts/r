---
layout: post
title: Увеличение производительности mysql
permalink: /uvelichenie-proizvoditelnosti-mysql.html
categories: [ktulhu]
---


		
Без преувеличения можно сказать что основой быстродействия mysql является наличие необходимых индексов над таблицами и наличие достаточного объема оперативной памяти для вмещения этих индексов.


Понять насколько эффективно происходит кэширование индексов в оперативной памяти можно выполнив запрос:

<pre>mysql> <strong>show status LIKE "Key%";</strong>
+------------------------+------------+
| Variable_name          | Value      |
+------------------------+------------+
| Key_blocks_not_flushed | 0          | 
| Key_blocks_unused      | 1256135    | 
| Key_blocks_used        | 458764     | 
| Key_read_requests      | <strong>8684644670</strong> | 
| Key_reads              | <strong>695044</strong>     | 
| Key_write_requests     | 20732504   | 
| Key_writes             | 7800079    | 
+------------------------+------------+
7 rows in set (0.00 sec)
</pre>

Соотношение показателей Key_reads (операция чтения с диска) и Key_read_requests (запросов к индексам) показывает достаточно ли отведено памяти для сохранения наиболее употребимых индексов. Соотношение 1/10000 как в этом примере свидетельствует о очень качественной работе буфера ключей. Только каждый 10000 запрос вызывает физическую операцию чтения файла индекса с диска. Если соотношение хуже чем 1/100 то нужно произвести настройку mysql для увеличения объема памяти отведенной под буферизацию индексов. Вот пример где под буфер индексов отводится 2 гигабайта памяти.


<strong>/etc/my.cnf:</strong>

<pre>
[mysqld]
max_connections=500
<strong>key_buffer_size=2048M</strong>
...
</pre>

Значение параметра key_buffer_size нужно подбирать исходя их объема дискового пространства занимаемого файлами индексов. В документации рекомендуется устанавливать его в размере 25% от объема RAM имеющейся на сервере. Но лучше исходить из реальной потребности конкретного сервера с конкретными базами данных и экспериментально подобрать значение дающее оптимальное соотношение показателей Key_reads / Key_read_requests.

			